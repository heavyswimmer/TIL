# 프로토타입
자바스크립트는 프로토타입 기반 언어이다. 프로토타입 기반 언어에서는 어떤 객체를 원형(prototype)으로 삼고 이를 복제(참조)함으로써 상속과 비슷한 효과를 얻는다. 따라서 자바스크립트에서 원시 타입을 제외한 모든 값들은 객체이다.

<br>

## 상속과 프로토타입
어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 **상속**이라 한다.

생성자 함수로 동일한 프로퍼티 구조를 갖는 객체를 여러 개 생성하게 되면, 모든 인스턴스가 동일한 메서드를 중복 생성하고 중복 소유하게 된다. 이는 메모리를 불필요하게 낭비시키고 퍼포먼스에도 악영향을 미친다.

프로토타입을 기반으로 **상속**을 구현하면 자신의 상태를 나타내는 프로퍼티만 개별적으로 소유하고 내용이 동일한 메서드는 상속을 통해 공유하여 사용할 수 있다, 이는 **코드의 재사용**이라는 관점에서 매우 유용하다.

<br>

## 프로토타입 객체
프로토타입 객체는 객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용된다.

모든 객체는 하나의 프로토타입을 갖는다. `[[Prototype]]`에 저장되는 프로토타입은 객체 생성 방식에 따라 다르다. 객체 리터럴에 의해 생성된 객체의 프로토타입은 `Object.prototype`이며 생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 `prototype` 프로퍼티에 바인딩되어 있는 객체다. 모든 프로토타입은 생성자 함수와 연결되어 있다.

<br>

### \_\_proto\_\_ 접근자 프로퍼티
- `__proto__` 접근자 프로퍼티는 상속을 통해 사용된다.
- 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유는 **상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서**이다. 

> ※ `__proto__` 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은
> 권장되지 않는다. 모든 객체가 `__proto__` 를 사용할 수 있는 것은 아니기 때문이다. 따라서 `__proto__` 접근자 프로퍼티 대신 `Object.getPrototypeOf` 메서드로 참조하고 `Object.setPropertyOf` 메서드로 프로토타입을 바꾸는 것을 권장한다.

### 함수 객체의 prototype 프로퍼티
함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.

<br>

## 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입
프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍(pair)으로 존재한다.

<br>

## 프로토타입의 생성 시점
프로토타입은 생성자 함수가 생성되는 시점에 함께 생성된다. 생성자 함수는 사용자 정의 생성자 함수와 빌트인 생성자 함수로 구분되기 때문에 둘의 프로토타입 생성 시점 또한 구분되어야 한다.

- 사용자 정의 생성자 함수 : constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 함께 생성된다. non-constructor는 프로토타입이 생성되지 않는다.

```js
// 함수 정의(constructor)가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
console.log(Person.prototype); // {constructor: f}

// 생성자 함수
function Person(name) {
  this.name = name;
}
```

- 빌트인 생성자 함수 : 전역 객체가 생성되는 시점에 생성된다.

<br>

## 객체 생성 방식과 프로토타입의 결정
객체의 생성 방식은 여러 가지가 있지만 모두 추상 연산 `OrdinaryObjectCreate` 에 의해 생성된다는 공통점이 있다. 추상 연산 `OrdinaryObjectCreate`는 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달받는다.